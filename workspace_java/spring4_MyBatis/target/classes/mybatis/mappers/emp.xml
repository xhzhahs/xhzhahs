<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
	PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.emp"> <!-- mapper로 구분한다. -->
	
	<!-- 이제부터 dao가 아닌 여기서 sql문 작성한다. -->
	<!-- id는 겹치면 안된다. -->


	<select id="selectEmp" resultType="kr.or.human4.dto.EmpDTO">
		select * from emp2
	</select>
	
	<!-- 
		resultType을 별칭을 쓸 수 있는 이유는 
		modelConfig.xml에서 typeAlias 별칭을 설정해놨기 때문이다. 
	-->
<!-- 	<select id="selectOneEmp" resultType="kr.or.human4.dto.EmpDTO"> -->
	<select id="selectOneEmp" resultType="empDTO">
		select * from emp2
		where empno = 7788
	</select>

	<!--
		HashMap은 너무 유명해서 
		별칭을 따로 지정하지 않아도 되어있다.
		별칭은 hashMap이다. 
	-->
<!-- 	<select id="selectOneEmpMap" resultType="java.util.HashMap"> -->
	<select id="selectOneEmpMap" resultType="hashMap">
		select * from emp2
		where empno = 7788
	</select>
	
<!-- 	<select id="selectEmpno" resultType="empDTO" parameterType="java.lang.Integer"> -->
	<select id="selectEmpno" resultType="empDTO" parameterType="int">
		select * from emp2
		<!-- 
			#{_parameter}는 ?와 같은 역할
			값이 한개 넘어올 때만 사용 
		-->
		where empno = #{_parameter}
	</select>

<!-- 	<select id="selectEmpno" resultType="empDTO" parameterType="java.lang.String"> -->
	<select id="selectEname" resultType="empDTO" parameterType="string">
		select * from emp2
		where upper(ename) like upper('%' || #{_parameter} || '%')
	</select>

<!-- 	<select id="selectEmpno" resultType="empDTO" parameterType="java.lang.String"> -->
	<select id="selectJob" resultType="empDTO" parameterType="string">
		select * from emp2
		where job = #{_parameter}
		<!-- 
			#{ } : ''를 자동으로 붙여 줌
			where ename = 'KING'
			where ename = 1234
			
			${ } : ''를 안붙임
			where ename = KING
			where ename = '${_parameter }'
			where ename = ''or '1' != '2'
		 -->
	</select>
	
	<select id="selectEmpnoEname" resultType="empDTO" parameterType="empDTO">
		select * from emp2
		<!-- getter를 실행해줌 -->
		where empno = #{empno} and ename = #{ename}
	</select>
	
	<!-- 시퀀스 사용할 시 -->
	<select id="getSeqEmp2" resultType="int">
		select seq_emp2.nextval from dual
	</select>
	
	<!-- insert -->
	<!-- resultType이 정해져 있어 따로 안써도 됨 -->
	<!-- 시퀀스를 따지만 DTO에 넣어주진 않는다. -->
	<insert id="insertEmp2" parameterType="empDTO">
		insert into emp2 (empno, ename, job, mgr, hiredate, sal, comm, deptno)
		values (seq_emp2.nextval, #{ename} , #{job}, #{mgr}, #{hiredate}, #{sal}, #{comm}, #{deptno})	
	</insert>

	<!-- update -->
	<update id="updateEmp2" parameterType="empDTO">
		update emp2
		set ename = #{ename},
			job = #{job},
			mgr = #{mgr},
			hiredate = #{hiredate},
			sal = #{sal},
			comm = #{comm},
			deptno = #{deptno}
		where empno = #{empno}
	</update>

	<!-- delete -->
	<!-- resultType이 정해져 있어 따로 안써도 됨 -->
	<delete id="deleteEmp2" parameterType="empDTO">
		delete from emp2
		where empno= #{empno}	
	</delete>
	
	
	<!-- 1번과 2번은 동일한 구문 -->
	<!-- 1. 시퀀스로 먼저 DTO에 넣고 인서트하기 -->
	<insert id="insertEmp3" parameterType="empDTO">
		
		<!-- selectKey 미리 sql문을 실행함 -->
		<!-- 
			order는 순서 before는 
			insert문이 실행하기 전에 실행해서 
			parameterType=empDTO에 넣어둠
		-->
		<selectKey resultType="int" keyProperty="empno" order="BEFORE">
			select seq_emp2.nextval from dual
		</selectKey>
	
		insert into emp2 (empno, ename, job, mgr, hiredate, sal, comm, deptno)
		values (#{empno}, #{ename} , #{job}, #{mgr}, #{hiredate}, #{sal}, #{comm}, #{deptno})	
	</insert>
	
	
	<!-- 2. 인서트할 때 시퀀스를 따서 DTO에 넣어줌 -->
	<!-- 
		keyProperty는 DTO의 필드명
		즉, setter 호출용이다. 
		얕은 복사로 넘어온 parameterType에 저장됨
		호출 주체인 DAO에서 저장된 empno등의 값을 사용 가능
	-->
	<!-- 
		useGeneratedKeys를 true로 하고
		keyProperty를 지정하면 parameterType에 저장된다.
		위의 selectKey와 비슷함.
	 -->
	<insert id="insertEmp4" parameterType="empDTO" useGeneratedKeys="true" keyProperty="empno">
	
		insert into emp2 (empno, ename, job, mgr, hiredate, sal, comm, deptno)
		values (seq_emp2.nextval, #{ename} , #{job}, #{mgr}, #{hiredate}, #{sal}, #{comm}, #{deptno})
	
	</insert>
	
	
	
</mapper>




